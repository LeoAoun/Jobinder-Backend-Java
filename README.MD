# Jobinder - API Backend üöÄ

Jobinder √© uma plataforma projetada para conectar profissionais que oferecem servi√ßos a clientes que os procuram, funcionando de forma similar a um "Tinder" para empregos e servi√ßos.

---

## üíª Tecnologias Utilizadas

- **Linguagem:** Java 17
- **Framework:** Spring Boot 3
- **Seguran√ßa:** Spring Security (autentica√ß√£o JWT)
- **Banco de Dados:** Spring Data JPA, PostgreSQL
- **Testes:** JUnit, Mockito
- **Comunica√ß√£o**:
  - REST APIs (Spring Web)
  - Comunica√ß√£o s√≠ncrona: Spring Cloud OpenFeign
  - Comunica√ß√£o ass√≠ncrona: RabbitMQ (Spring AMQP)
  - Tempo Real: Spring WebSocket
- **Documenta√ß√£o: SpringDoc OpenAPI 3 (Swagger)**
- **Build:** Apache Maven
- **Containeriza√ß√£o:** Docker & Docker Compose
- **Utilit√°rios:** Lombok

## üèõÔ∏è Arquitetura de Microsservi√ßos

O backend da plataforma segue uma arquitetura de microsservi√ßos orientada a eventos, com cada servi√ßo tendo seu pr√≥prio banco de dados (Database per Service) para garantir o desacoplamento e a escalabilidade.

### Servi√ßos Principais

- **Auth Service (Porta 8080):** Respons√°vel pela autentica√ß√£o (`/login`) e gera√ß√£o de tokens JWT. √â _stateless_ (sem banco de dados) e consulta o `identity-service` para validar as credenciais do usu√°rio.
- **Identity Service (Porta 8081):** O "servi√ßo de verdade" (source of truth) para identidade. Gerencia o cadastro de usu√°rios (`User`), perfis de servi√ßo (`ServiceProfile`), `Locations` e `Specialties`. Armazena os dados em seu pr√≥prio banco.
- **Matching Service (Porta 8082):** Gerencia a l√≥gica de "match" entre um cliente e um profissional. Quando um match √© criado, ele salva o `Match` em seu banco de dados e publica um evento `MatchCreatedEvent` no RabbitMQ.
- **Chat Service (Porta 8083):** Consome eventos de match do RabbitMQ para criar `Conversations`. Gerencia a comunica√ß√£o em tempo real entre os usu√°rios (via WebSockets) e armazena o hist√≥rico de `Messages` em seu banco.

### Depend√™ncias de Infraestrutura

- **PostgreSQL:** Banco de dados relacional. Cada servi√ßo (Identity, Matching, Chat) gerencia seu pr√≥prio schema.
- **RabbitMQ:** Message broker usado para a comunica√ß√£o ass√≠ncrona entre o `Matching Service` e o `Chat Service`.

## Diagrama de Arquitetura

```mermaid
flowchart TD
    subgraph "Cliente (Web/Mobile)"
        A[Usu√°rio]
    end

    subgraph "Infraestrutura"
        MQ[(RabbitMQ)]

        subgraph "Bancos de Dados"
            DB_Auth[(Auth DB<br/>PostgreSQL)]
            DB_Identity[(Identity DB<br/>PostgreSQL)]
            DB_Matching[(Matching DB<br/>PostgreSQL)]
            DB_Chat[(Chat DB<br/>PostgreSQL)]
        end
    end

    subgraph "Auth Service: 8080"
        AS[Auth Service]
    end

    subgraph "Identity Service: 8081"
        IS[Identity Service]
    end

    subgraph "Matching Service: 8082"
        MS[Matching Service]
    end

    subgraph "Chat Service: 8083"
        CS[Chat Service]
    end

    %% Fluxo de Autentica√ß√£o
    A -->|1. Login telefone, senha| AS
    AS -->|2. Valida credenciais via Feign| IS
    IS -->|3. Retorna dados do usu√°rio| AS
    AS -->|4. Gera e retorna JWT| A

    %% Conex√µes com Bancos
    AS -->|Armazena tokens<br/>e sess√µes| DB_Auth
    IS -->|Armazena usu√°rios<br/>e perfis| DB_Identity
    MS -->|Armazena matches<br/>e prefer√™ncias| DB_Matching
    CS -->|Armazena conversas<br/>e mensagens| DB_Chat

    %% Fluxo de Registro/Perfil
    A -->|5. Registra, Cria Perfil, etc.| IS

    %% Fluxo de Matching
    A -->|6. Cria Match| MS
    MS -->|7. Publica MatchCreatedEvent| MQ

    %% Fluxo de Chat
    MQ -->|8. Consome MatchCreatedEvent| CS
    CS -->|9. Cria conversa automaticamente| DB_Chat

    %% Comunica√ß√£o WebSocket
    A -->|10. Conecta via WebSocket| CS
    A -->|11. Envia/Recebe Mensagens| CS

    class DB_Auth auth-database
    class DB_Identity identity-database
    class DB_Matching matching-database
    class DB_Chat chat-database

    classDef auth-database fill:#e1f5fe
    classDef identity-database fill:#f3e5f5
    classDef matching-database fill:#e8f5e8
    classDef chat-database fill:#fff3e0
```

## üè¶ Esquemas de Banco de Dados

Abaixo est√£o os esquemas de banco de dados para cada servi√ßo.

### Identity Service

<p align="center">
  <img src="./readme-images/Identity-Service-Schema.png" width="60%" />
</p>

### Matching Service

<p align="center">
  <img src="./readme-images/Matching-Service-Schema.png" width="35%" />
</p>

### Chat Service

<p align="center">
  <img src="./readme-images/Chat-Service-Schema.png" width="60%" />
</p>

## ‚úÖ Testes Unit√°rios

O projeto possui uma su√≠te de testes unit√°rios para garantir a confiabilidade da l√≥gica de neg√≥cios e a integridade dos dados.

- **Cobertura:**
  - Testes cobrem todos **Microservices** (`Auth Service`, `Identity Service`, `Matching Service`, `Chat Service`).
  - Valida√ß√£o de cen√°rios de sucesso ("caminho feliz") e tratamento de exce√ß√µes (erros de neg√≥cio, dados inv√°lidos).
  - Testes de integridade de dados e mapeamento de DTOs.

### Como Rodar os Testes

**Op√ß√£o 1: Script Automatizado (Recomendado)**

Na ra√≠z do projeto, execute todos os testes de uma vez:

```bash
# Linux / Mac / Git Bash
./test-all.sh

# Windows (CMD / PowerShell)
./test-all.bat
```

**Op√ß√£o 2: Manualmente por Servi√ßo**

Navegue at√© a pasta do servi√ßo desejado e execute:

```bash
cd ./{service-name}
./mvnw test
```

## üìñ Documenta√ß√£o da API (Swagger)

Ap√≥s iniciar os servi√ßos (com qualquer um dos m√©todos acima), a documenta√ß√£o da API de cada servi√ßo estar√° dispon√≠vel nos seguintes links:

- **Auth Service:** http://localhost:8080/swagger-ui.html
- **Identity Service:** http://localhost:8081/swagger-ui.html
- **Matching Service:** http://localhost:8082/swagger-ui.html
- **Chat Service:** http://localhost:8083/swagger-ui.html

---

# üöÄ Como Rodar o Projeto

A forma mais recomendada de rodar o projeto √© usando Docker Compose, que subir√° todos os servi√ßos e a infraestrutura necess√°ria (Banco de Dados e RabbitMQ) automaticamente.

## Pr√©-requisitos

- Java 17 (ou superior)
- Apache Maven
- Docker e Docker Compose (geralmente j√° vem com o Docker Desktop)

## Rodando com Docker Compose (Recomendado)

### 1. Clone o Reposit√≥rio:

```bash
git clone https://github.com/LeoAoun/Jobinder-Backend-Java.git
cd jobinder-backend-java
```

### 2. Configurar Vari√°veis de Ambiente (Obrigat√≥rio):

O docker-compose.yml est√° configurado para ler segredos (como JWT_SECRET) de um arquivo .env.

### 3. Subir os Containers:

No terminal, na pasta raiz (onde est√° o docker-compose.yml), execute:

```bash
docker-compose up --build
```

Nota: O --build for√ßa o Docker a construir as imagens do zero usando os Dockerfiles de cada servi√ßo. Isso pode levar alguns minutos na primeira vez.

### 4. Acessar os Servi√ßos:

Ap√≥s os logs estabilizarem, os servi√ßos estar√£o dispon√≠veis:

- **Auth Service:** http://localhost:8080
- **Identity Service:** http://localhost:8081
- **Matching Service:** http://localhost:8082
- **Chat Service:** http://localhost:8083
- **RabbitMQ Admin:** http://localhost:15672 (login: guest / guest)
- **PostgreSQL DB:** Acess√≠vel em localhost:5432 (login: postgres / postgres)

## Rodando Localmente (Alternativa, para Debug)

Voc√™ tamb√©m pode rodar cada servi√ßo individualmente pela sua IDE (IntelliJ, VS Code, etc.).

1. **Inicie as Depend√™ncias:** Voc√™ precisa ter inst√¢ncias do PostgreSQL e RabbitMQ rodando localmente (ou via Docker).
2. **Configure os application.properties:** Certifique-se de que cada application.properties (em cada pasta de servi√ßo) aponte para localhost (ex: spring.datasource.url=jdbc:postgresql://localhost:5432/...).
3. **Inicie cada Servi√ßo:** Abra cada pasta de microsservi√ßo (ex: auth-service, identity-service) e inicie a aplica√ß√£o Spring Boot (pelo main ou mvn spring-boot:run).
